(function () {

    angular.module('pointApp', ['ngRoute', 'ui.bootstrap', 'ngResource', 'ngFileSaver', 'ngMaterial']);

    function config($routeProvider) {
        $routeProvider
            .when('/', {
                templateUrl: '/home/home.view.html',
                controller: 'homeCtrl'
            })
            .when('/edit/:id', {
                templateUrl: '/list/create_edit.view.html',
                controller: 'listCreateEditCtrl',
                resolve: {
                    points: function (dataService, $route) {
                        return dataService.get({ list_id: $route.current.params.id });
                    }
                }     

            })
            .when('/create', {
                controller: 'listCreateEditCtrl',
                templateUrl: '/list/create_edit.view.html',
                resolve: {
                    points: function () {
                        return {name: '', xy: []};
                    }
                }

            })
            .otherwise({ redirectTo: '/' });

        //$locationProvider.html5Mode(true);
    }


    angular.module('pointApp')
        .config(['$routeProvider', '$locationProvider', config]);

})();
(function () {

    angular
        .module('pointApp')
        .controller('homeCtrl', function ($scope, dataService, $location) {

            $scope.editList = function (listId) {
                $location.path('/edit/' + listId);
            }

            $scope.createList = function () {
                $location.path('/create/');
            }

            function getItems() {
                $scope.lists = dataService.query(function () {
                    console.log($scope.lists);
                }, function (err) {

                });
            }

            $scope.deleteList = function (listId) {
                dataService.delete({ list_id: listId }, function () {
                    getItems();
                });
            }


            getItems();
        });



})();
(function () {

    angular
        .module('pointApp')
        .controller('listCreateEditCtrl', function ($scope, dataService, calcService, FileSaver, pagination, $mdDialog, points) {
            var original = {};
            $scope.point = {};
            $scope.errors = [];
            $scope.paginator = pagination;
            $scope.pageSizes = [5, 10, 20, 50];
            $scope.selectedTabIndex = 0;

            if (points.$promise != undefined) {
                points.$promise.then(function (result) {
                    $scope.points = result;
                    original = angular.copy($scope.points.xy);
                    $scope.paginator.initPagination($scope.points.xy);
                });

            } else {
                $scope.points = points;
                original = angular.copy($scope.points.xy);
                $scope.paginator.initPagination($scope.points.xy);

            }


            $scope.showPrompt = function (ev) {
                if ($scope.points.xy.length > 0) {
                    var confirm = $mdDialog.prompt()
                        .title('Save a list')
                        .textContent('List with same name will be overrided')
                        .placeholder('Please enter a name')
                        .ariaLabel('Please enter a name')
                        .initialValue($scope.points.name)
                        .targetEvent(ev)
                        .ok('Save')
                        .cancel('Cancel');
                    $scope.status = "";
                    $mdDialog.show(confirm).then(
                        function (result) {
                            createDialogAction(result);
                        }, function () {
                             
                        });

                } else
                    $scope.errors.push({ message: "Add some points: ", value: "5000 >= x, y >= -5000" });
            }
             

            var createDialogAction = function (name) {
                var entry = new dataService();
                entry.name = name;
                entry.xy = $scope.points.xy;
                entry.$save(function (res) {
                    original = angular.copy($scope.points.xy);
                    $scope.status = res.message;
                }, function (err) {
                    $scope.status = "Error";
                });
            }


            $scope.displayFileContents = function (contents) {
                $scope.selectedTabIndex = 0;
                $scope.clearError();
                $scope.points.xy = $scope.points.xy.concat(contents);
                $scope.points.xy = calcService.removeDuplicates($scope.points.xy);
                $scope.errors.push(...calcService.errorMsg);
                $scope.paginator.initPagination($scope.points.xy);
            };


            var resetForm = function () {
                $scope.point = {};
                $scope.createForm.$setUntouched();
                $scope.createForm.$setPristine();
            }

            $scope.add = function () {
                $scope.selectedTabIndex = 0;
                if ($scope.createForm.$valid) {
                    if (calcService.checkValue({ 0: $scope.point.x, 1: $scope.point.y })) {
                        var index = $scope.points.xy.findIndex(x => x.x === $scope.point.x && x.y === $scope.point.y);
                        if (index === -1) {
                            $scope.points.xy.push($scope.point);
                            resetForm();
                            $scope.paginator.initPagination($scope.points.xy);
                        }
                        else $scope.errors.push({ message: "Duplicate found: ", value: $scope.point.x + " " + $scope.point.y });

                    }
                    else if ($scope.points.xy.length === 10000) {
                        $scope.errors.push({ message: "List is full: ", value: $scope.points.xy.length });
                    } else
                        $scope.errors.push({ message: "Value is incorrect: ", value: $scope.point.x + " " + $scope.point.y });
                }
            }


            $scope.download = function () {
                var dataFile = calcService.dataForDownload($scope.points);
                var data = new Blob([dataFile], { type: 'text/plain' });
                FileSaver.saveAs(data, $scope.points.name + '.txt');
            };

            $scope.remove = function (point) {
                var index = $scope.points.xy.indexOf(point);
                if (index != -1) {
                    $scope.points.xy.splice(index, 1);
                    $scope.paginator.initPagination($scope.points.xy);
                }

            };

            $scope.clearError = function () {
                $scope.errors = [];
                calcService.errorMsg = [];
            }

            $scope.clear = function () {
                angular.copy(original, $scope.points.xy);
                if ($scope.selectedTabIndex === 0)
                    $scope.paginator.initPagination($scope.points.xy);
            }
              

            $scope.$watch("squares", function () {
                if ($scope.squares) {
                    if ($scope.squares.length > 0) {
                        $scope.paginator.initPagination($scope.squares);
                        $scope.selectedTabIndex = 1;
                    }
                }
            }
            );



            $scope.onTabChanges = function (currentTabIndex) {
                $scope.selectedTabIndex = currentTabIndex;
                if ($scope.selectedTabIndex === 0 && $scope.points) {
                    $scope.paginator.initPagination($scope.points.xy);
                } else if ($scope.squares)
                    $scope.paginator.initPagination($scope.squares);

            };


            $scope.formSquare = function () {
                 
                $scope.squares = calcService.findSquares($scope.points.xy);
                if ($scope.squares.length === 0) {
                    $scope.errors.push({ message: "Current list don't have any square", value: "" });
                }
            }
        });



})();
(function () {
    angular.module('pointApp')
        .directive('linkClick', function ($location) {
            return function (scope, element, attrs) {
                var path;

                attrs.$observe('linkClick', function (val) {
                    path = val;
                });

                element.bind('click', function () {
                    scope.$apply(function () {
                        $location.path(path);
                    });
                });
            };
        });

})();

(function () {
    angular
        .module('pointApp')
        .directive('onReadFile', function($parse, calcService) {
            return {
                restrict: 'A',
                scope: false,
                link: function(scope, element, attrs) {
                    element.bind('change', function(e) {
                        var onFileReadFn = $parse(attrs.onReadFile);
                        var reader = new FileReader();
                        reader.onload = function() {
                            var fileContents = reader.result;
                            fileContents = calcService.toArrayOfObject(fileContents);
                            scope.$apply(function() {
                                onFileReadFn(scope, {
                                    'contents': fileContents

                                });

                            });

                        }
                        if (element[0].files[0])
                            reader.readAsText(element[0].files[0]);
                    });

                }
            }

        });

})();
(function () {
    angular.module('pointApp')
        .service('calcService', 
        function () {

            var calService = {
                errorMsg: []
            }

            var compare = function (a, b) {

                if (a.x !== b.x) return false;
                if (a.y !== b.y) return false;
                return true;
            }


           var checkForNegativeExtremes = function (slope) {
                if (!isFinite(slope) || slope === -0.0) {
                    slope = Math.abs(slope);
                }
                return slope;
            }

            Array.prototype.contains = function (obj) {
                var i = this.length;
                while (i--) {
                    if (
                        (this[i].a.x === obj.a.x && this[i].a.y === obj.a.y &&
                            this[i].b.x === obj.b.x && this[i].b.y === obj.b.y) ||
                        (this[i].a.x === obj.b.x && this[i].a.y === obj.b.y &&
                            this[i].b.x === obj.a.x && this[i].b.y === obj.a.y)
                    ) {
                        return true;
                    }
                }
                return false;
            }


            calService.findSquares = function (data) {

                var all = data;
                var m = new Map();
                var squares = [];

                for (var d = 0; d < all.length - 1; d++) {
                    var a = all[d];
                    for (var j = d + 1; j < all.length; j++) {
                        var b = all[j];
                        if (compare(a, b)) continue;
                        var sl = checkForNegativeExtremes((a.y - b.y) / (a.x - b.x));
                        var set = m.get(sl);
                        if (set === null || set === undefined) {
                            m.set(sl, set = new Set());
                        }
                        set.add({
                            a,
                            b
                        });

                    }
                }

                var keys = Array.from(m.keys());
                //keys.sort();
                for (var k = 0; k < keys.length; k++) {

                    var slope = keys[k];

                    var lTmp = m.get(slope);
                    if (lTmp === undefined || lTmp.size <= 1) continue;
                    var slopePerpendicular = checkForNegativeExtremes(-1. / slope);

                    var perpendiculars = m.get(slopePerpendicular);
                    m.delete(slopePerpendicular);
                    if (perpendiculars == undefined || perpendiculars.size <= 1) continue;
                    var per = Array.from(perpendiculars);
                    var l = Array.from(lTmp);
                    for (var i = 0; i < l.length - 1; i++) {
                        var l1 = l[i];
                        for (var j = i + 1; j < l.length; j++) {
                            var l2 = l[j];
                            if (per.contains({
                                a: l1.a,
                                b: l2.a
                            }) && per.contains({
                                a: l1.b,
                                b: l2.b
                            }) ||
                                per.contains({
                                    a: l1.a,
                                    b: l2.b
                                }) && per.contains({
                                    a: l1.b,
                                    b: l2.a
                                })) {
                                squares.push({
                                    A: l1.a,
                                    B: l1.b,
                                    C: l2.a,
                                    D: l2.b
                                });

                            }
                        }
                    }
                };
                return squares;
            }


            calService.dataForDownload = function (dataArray) {
                var data = [];
                var temp = "";
                for (var i in dataArray.xy) {
                    for (var key in dataArray.xy[i]) {
                        if (key.length === 1) {
                            if (!temp) {
                                temp = dataArray.xy[i][key].toString() + " ";
                            } else
                                temp = temp.concat(dataArray.xy[i][key].toString() + "\n");

                        }
                    }
                    data.push(temp);
                    temp = "";
                }
                return data.toString().replace(/\,/g, "");
            }


            calService.removeDuplicates = function (originalArray) {
                var trimmedArray = [];
                var values = [];
                var valueX, valueY;

                for (var i = 0; i < originalArray.length; i++) {
                    valueX = originalArray[i]['x'];
                    valueY = originalArray[i]['y'];

                    var index = values.findIndex(x => x.x === valueX && x.y === valueY);

                    if (index === -1) {
                        trimmedArray.push(originalArray[i]);
                        values.push({
                            "x": valueX,
                            "y": valueY
                        });
                    } else calService.errorMsg.push({
                        message: "Duplicate found: ",
                        value: valueX + " " + valueY
                    });
                }

                return trimmedArray;

            }


            isInt = function (val) {
                var intRegex = /^-?\d+$/;
                if (!intRegex.test(val))
                    return false;

                var intVal = parseInt(val, 10);
                return parseFloat(val) == intVal && !isNaN(intVal);
            }

            calService.checkValue = function (xy) {
                if (isInt(xy[0]) && isInt(xy[1])) {
                    if (parseInt(xy[0], 10) >= -5000 && parseInt(xy[1], 10) >= -5000 && parseInt(xy[0], 10) <= 5000 && parseInt(xy[1], 10) <= 5000)
                        return true;
                    calService.errorMsg.push({
                        message: "Value is incorrect: ",
                        value: xy[0] + " " + xy[1]
                    });
                } else if (xy[0].length && xy[1].length)
                    calService.errorMsg.push({
                        message: "Value is incorrect: ",
                        value: xy[0] + " " + xy[1]
                    });
                return false;
            }


            calService.toArrayOfObject = function (contents) {
                var splitedArray = [];
                contents.split(/\r\n|\r|\n/).map(function (i) {
                    var xy = i.split(" ");
                    if (calService.checkValue(xy))
                        if (splitedArray.length <= 10000) {
                            splitedArray.push({
                                "x": parseInt(xy[0], 10),
                                "y": parseInt(xy[1], 10)
                            });
                        } else
                            calService.errorMsg.push({
                                message: "List is full: ",
                                value: splitedArray.length
                            });

                    return;
                });
                return splitedArray;
            }

          

            return calService;

        });

})();
(function () {
    angular.module('pointApp')
        .service('dataService', ['$resource',
            function ($resource, $route) {
                return $resource('/api/list/:list_id', { list_id: '@list_id' }, {
                    update: { method: 'PUT', params: { list_id: '@name' } }
                });
            }]);

})();
(function () {
    var paginationModule = angular.module('pointApp');

    paginationModule.factory('pagination', function () {


        var paginator = {
            currentPage: 0,
            itemsPerPage: 5,
            pagedItems: [],
            filteredItems: [],
            reverse: false,
            sortingOrder: 'x'
        }; 
          
          
        paginator.initPagination = function (data) {
            if (data != undefined ) {
                paginator.filteredItems = data;
                paginator.groupToPages();
            }
        };


        //// change sorting order
        paginator.sort_by = function (newSortingOrder) {
            if (paginator.sortingOrder == newSortingOrder)
                paginator.reverse = !paginator.reverse;

            paginator.sortingOrder = newSortingOrder;
        };


        paginator.prevPage = function () {
            if (paginator.currentPage > 0) {
                paginator.currentPage--;
            }
        };

        paginator.nextPage = function () {
            if (paginator.currentPage < paginator.pagedItems.length - 1) {
                paginator.currentPage++;
            }
        };
        paginator.setPage = function (n) {
            paginator.currentPage = n;
        };

        paginator.groupToPages = function () {
            paginator.pagedItems = [];

            for (var i = 0; i < paginator.filteredItems.length; i++) {
                if (i % paginator.itemsPerPage === 0) {
                    paginator.pagedItems[Math.floor(i / paginator.itemsPerPage)] = [paginator.filteredItems[i]];
                } else {
                    paginator.pagedItems[Math.floor(i / paginator.itemsPerPage)].push(paginator.filteredItems[i]);
                }
            }

        };

        // show items per page
        paginator.perPage = function () {
            paginator.groupToPages();
        };

        paginator.range = function (start, end) {
            var ret = [];
            if (!end) {
                end = start;
                start = 0;
            }
            for (var i = start; i < end; i++) {
                ret.push(i);
            }
            return ret;
        };


        return paginator;
    });


})();
//# sourceMappingURL=app.min.js.map
